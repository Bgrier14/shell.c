//------------------------------
//Brendan Grier
//3/25/2021
//UNIX Shell Project 2
//------------------------------

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

#define READER 0
#define WRITER 1

int tpipe_rhs(char** cheddar);

char** purse(char* input, char* cheddar[])
{
    int numbers = 0;
    const char limit[2] = {' ', '\t'};
    char* coin;
    
    coin = strtok(input, limit);
    cheddar[0] = coin;

    char** detour = malloc(2 * sizeof(char*));
    for(int x = 0; x < 2; ++x)
        detour[x] = malloc(BUFSIZ * sizeof(char));
        detour[0] = "";
        detour[1] = "";

    while(coin != NULL)
    {
        coin = strtok(NULL, limit);
        if(coin == NULL)
        break;
        if(!strncmp(coin, ">", 1))
        {
            coin = strtok(NULL, limit);
            detour[0] = "o";
            detour[1] = coin;
            return detour;
        }
        else if(!strncmp(coin, "<", 1))
        {
            coin = strtok(NULL, limit);
            detour[0] = "i";
            detour[1] = coin;
            return detour;
        }
        else if(!strncmp(coin, "|", 1))
        {
            detour[0] = "p";
        }
        cheddar[++numbers] = coin;
    }
    return detour;
}

int main(int argc, const char* argv[])
{
    char input [BUFSIZ];
    char mars   [BUFSIZ]; 
    int fdpi[2];

    memset(input, 0, BUFSIZ * sizeof(char));
    memset(mars, 0, BUFSIZ * sizeof(char));

    while(1)
    {
        printf("osh> ");//console input for the shell
        fflush(stdout);
        fgets(input, BUFSIZ, stdin);
        input[strlen(input) - 1] = '\0';
        if(strncmp(input, "exit", 4) == 0)
            return 0;
        if(strncmp(input, "!!", 2))
            strcpy(mars, input);
        bool wewait = true;
        char* waitfor = strstr(input, "&");
        if(waitfor != NULL) 
        {
            *waitfor = ' '; wewait = false;
        }
        pid_t pid = fork();//setting up the fork for the parent ID
        if(pid < 0)
        {
            fprintf(stderr, "FORK FAILED \n");
            return -1;//if the for was to fail the program will exit
        }
        if(pid != 0)//no infinite loop
        {
            if(wewait)
            {
            wait(NULL);
            }
        }
        else
        {
            //not really too sure what is going on here, had to get help
            char* cheddar[BUFSIZ];
            memset(cheddar, 0, BUFSIZ * sizeof(char));
            int value = 0;
            if(!strncmp(input, "!!", 2))
            value = 1;
            char** redirect = purse((value ? mars : input), cheddar);
            if(value && mars[0]== '\0')
            {
                printf("NO COMMAND IN MEMORY \n");
                exit(0);
            }
            if(!strncmp(redirect[0], "o", 1))
            {
                printf("OUTPUT SAVED TO ./%s\n", redirect[1]);
                int fileD = open(redirect[1], O_TRUNC | O_CREAT | O_RDWR);
                dup2(fileD, STDOUT_FILENO);
            }
        else if(!strncmp(redirect[0], "i", 1))
        {
            printf("READING FROM FILE: ./%s\n", redirect[1]);
            int fileD = open(redirect[1], O_RDONLY);
            memset(input, 0, BUFSIZ * sizeof(char));
            read(fileD, input,  BUFSIZ * sizeof(char));
            memset(cheddar, 0, BUFSIZ * sizeof(char));
            input[strlen(input) - 1]  = '\0';
            purse(input, cheddar);
        }
        else if (!strncmp(redirect[0], "p", 1))
        {
            pid_t pidc;
            int rhs_o = tpipe_rhs(cheddar);
            cheddar[rhs_o] = "\0";
            int e = pipe(fdpi);
            if(e < 0)
            {
            fprintf(stderr, "PIPE CREATION FALIED \n");
            return 1;
            }
        char* lhs[BUFSIZ], *rhs[BUFSIZ];
        memset(lhs, 0, BUFSIZ*sizeof(char));
        memset(rhs, 0, BUFSIZ*sizeof(char));
        for(int x = 0; x < rhs_o; ++x)
        {
            lhs[x]= cheddar[x];
        }
        for(int x = 0; x < BUFSIZ; ++x)
        {
            int i = x + rhs_o + 1;
            if(cheddar[i] == 0) break;
            rhs[x] = cheddar[i];
        }
        pidc = fork();
        if(pidc < 0)
        {
            fprintf(stderr, "FORK FAILED \n");
            return 1;
        }
        if(pidc != 0)
        { 
            dup2(fdpi[WRITER], STDOUT_FILENO);
            close(fdpi[WRITER]);
            execvp(lhs[0], lhs);
            exit(0); 
        }
        else
        {
            dup2(fdpi[READER], STDIN_FILENO);
            close(fdpi[READER]);
            execvp(rhs[0], rhs);
            exit(0);  
        }
        wait(NULL);
        }
        execvp(cheddar[0], cheddar);
        exit(0);  
        }
    }
    return 0;
}

//finds the pipe
int tpipe_rhs(char** cheddar)
{
    int i = 0;
    while(cheddar[i] != NULL)
    {
        if(!strncmp(cheddar[i], "|", 1))
        {
            return i;
        }
        i++;
    }
    return -1;
}

//----------------------------------------------------------------------
//OUTPUT FOR shell.c
//----------------------------------------------------------------------
// osh> cal
//      March 2021       
// Su Mo Tu We Th Fr Sa  
//     1  2  3  4  5  6  
//  7  8  9 10 11 12 13  
// 14 15 16 17 18 19 20  
// 21 22 23 24 25 26 27  
// 28 29 30 31           
                      
// osh> ls
// CriticalRegion.c  mutexes.c  out  Philosophers.c  pingpong.c  Project-1-CPCS-351  shell  shell.c  shell_skeleton.c  Simple-Semaphores
// osh> exit
//----------------------------------------------------------------------
//END OF OUTPUT FOR shell.c
//----------------------------------------------------------------------
